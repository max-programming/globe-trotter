---
alwaysApply: true
---

## TanStack Start — Cursor Rules and Conventions (Generic)

This guide documents structure, routing, data-fetching, naming, and implementation rules for TanStack Start apps. It is project-agnostic and can be copied into any project using TanStack Router + Start.

### Tech stack assumptions

- React 18, TanStack Start (Router + Server), React Query
- A server-side data layer (ORM or API) accessed only via server functions or server file routes
- TailwindCSS and a component library (optional)

## Directory structure (recommended)

- `src/router.tsx`: Router factory; wires `routeTree`, `QueryClient`, defaults
- `src/routeTree.gen.ts`: Generated by TanStack Router — never edit
- `src/routes/`: File-based routes (UI routes and server file routes)
  - `__root.tsx`: Root route; sets app-wide context (e.g., session); provides `<HeadContent>`, `<Scripts>`, NotFound
  - Group routes: `(group-name)/` folders for layout-only grouping that don’t affect URL paths
  - Dynamic params: `$param/` folders for path params
  - API routes: `api/*.ts` defined using `createServerFileRoute`
- `src/server-functions/`: RPC functions defined with `createServerFn`, consumed from the client via `useServerFn`
- `src/lib/`:
  - `queries/`: React Query `queryOptions` creators
  - `mutations/`: Hooks built on `useMutation`
  - `db/` or `services/`: Data access and schema (if applicable)
  - Shared utilities (e.g., `auth.ts`, `utils.ts`)
- `src/components/`: UI and feature components; `ui/` for primitives
- `src/server.ts`: Start handler wiring with router factory
- `styles/app.css`: Global styles (Tailwind entry if used)

## Routing conventions

- Use file-based routing with TanStack Router
  - Group segments: `(...)` are layout-only; they do not change URL paths
  - Dynamic params: `$param` denotes a route param folder
  - `index.tsx` is the default child route
- Root route context
  - In `__root.tsx`, set route context in `beforeLoad` (e.g., fetch session via a query)
  - Provide `head`, `component`, and `notFoundComponent`
- Guards
  - Implement guards in `beforeLoad` of layout routes (e.g., auth-required dashboard group)
  - Use typed redirects with `redirect({ to, params, search })`
- Data preloading
  - In route `loader`, warm caches using `context.queryClient.ensureQueryData(query)`
- Navigation
  - Use typed `navigate` from route instances or `useNavigate()`
  - Use `<Navigate .../>` for immediate in-component redirects
- Error handling
  - Provide `errorComponent` per route; handle `PathParamError` when validating params

## Data fetching conventions

- Queries belong in `src/lib/queries/*`
  - Export functions named `getXyzQuery`, returning `queryOptions({ queryKey, queryFn, ... })`
  - Use tuple query keys with a stable namespace first entry, e.g., `["projects", id]`
  - Make `queryFn` call server functions (keep business logic server-side)
- Client usage
  - Preload with `ensureQueryData` in route `loader`
  - Read via `useQuery(getXyzQuery(arg))` or `useSuspenseQuery(getXyzQuery(arg))`

## Mutations conventions

- Mutations belong in `src/lib/mutations/*`
  - Export hooks named `useXyz` wrapping `useMutation`
  - Call server functions via `useServerFn(serverFn)`
  - Implement optimistic updates with `onMutate` and rollback in `onError`
  - Invalidate affected queries in `onSettled`/`onSuccess`
  - Navigate on success if UX requires

## Server functions (RPC) conventions

- Define with `createServerFn({ method })` in `src/server-functions/*`
  - Validate inputs with zod (route params, search, and bodies)
  - Apply authentication/authorization middleware as needed
  - Access headers via `getWebRequest()` when necessary
  - Throw domain errors or `notFound()` for missing resources

## Server file routes (HTTP API) conventions

- Define with `createServerFileRoute("/api/...")` under `src/routes/api/*`
  - Use request/response middlewares (e.g., bearer auth) as needed
  - Validate URL params and JSON bodies with zod
  - Return `Response.json(...)` for JSON payloads

## Forms and validation

- Co-locate zod schemas next to UI forms or domain modules
- Validate route params using `params: { parse: (p) => ({ ... }) }`
- Pass typed `UseFormReturn<T>` to mutation hooks and surface server errors back to forms

## Component conventions

- UI primitives under `src/components/ui/*`; feature components under domain folders
- Styling: TailwindCSS classes preferred; avoid custom CSS files unless necessary
- Accessibility: Labeled controls, keyboard support, logical headings, ARIA where needed
- Suspense: Provide `*Skeleton` fallbacks for data-driven components and use `<Suspense>` where useful

## Naming rules

- Files
  - Routes: kebab-case files; dynamic `$param` folders; group folders `(<name>)`
  - Components: PascalCase, single-export preferred
  - Hooks: `use-*.ts` under `hooks` or `lib/mutations/*`
  - Queries: `lib/queries/<domain>.ts` exporting `getXyzQuery`
  - Server functions: `server-functions/<domain>.ts` exporting verbs (`getXyz`, `addXyz`)
- Identifiers
  - Components: PascalCase
  - Hooks: `useThing`
  - Query keys: const tuple with stable namespace first
  - Event handlers: `handleClick`, `handleChange`, etc.

## Implementation guidelines

- Prefer early returns; avoid deep nesting
- Keep business logic on the server (server functions or server file routes)
- Encrypt sensitive values client-side if your domain requires it; never send plaintext secrets
- Avoid database access directly from components
- Do not edit generated files like `routeTree.gen.ts`

## Adding a new feature (checklist)

1. Data model: Update your schema/data layer and run a migration if applicable
2. Server function: Add `createServerFn` with zod validation and required middleware
3. Query: Add `getThingQuery` in `lib/queries/<domain>.ts`
4. Route: Create file under `src/routes/...`; `loader` should `ensureQueryData(getThingQuery(...))`
5. Component: Build UI under `src/components/...` with Tailwind and optional Suspense/skeletons
6. Mutation: Add `useAddThing` under `lib/mutations/<domain>` with optimistic updates and invalidations
7. Navigation: Use typed `navigate({ to, params, search })`

## Canonical snippets

Query creator:

```ts
export const getProjectsQuery = queryOptions({
  queryKey: ["projects", "home"] as const,
  queryFn: getProjects,
});
```

Route with loader and param parsing:

```ts
export const Route = createFileRoute("/(group)/$id")({
  params: { parse: (p) => ({ ...p, id: idSchema.parse(p.id) }) },
  loader: ({ context, params }) =>
    context.queryClient.ensureQueryData(getDetailsQuery(params.id)),
  component: DetailsPage,
});
```

Mutation with optimistic update and navigation:

```ts
return useMutation({
  mutationFn: async (data) => addItemFn({ data }),
  onMutate: async (vars) => {
    /* cancel, snapshot, optimistic set */
  },
  onError: (_e, vars, ctx) => {
    /* rollback */
  },
  onSuccess: (item, vars) => navigate({ to: "/$id", params: { id: item.id } }),
  onSettled: () => queryClient.invalidateQueries({ queryKey: ["items"] }),
});
```

Server file route with bearer auth:

```ts
export const ServerRoute = createServerFileRoute("/api/$id/resource").methods(
  (api) => ({
    GET: api
      .middleware([bearerAuthMiddleware])
      .handler(async ({ context, params }) => {
        return Response.json({ id: params.id });
      }),
  })
);
```

## Runtime assumptions

- Root route sets shared context (e.g., session) via a query in `beforeLoad`
- React Query is the single source of truth for remote data
- Server enforces authz/authn; clients orchestrate and render
